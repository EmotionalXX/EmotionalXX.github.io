---
layout:     post
title:      [Python基础语法]
subtitle:   Python
date:       2019-1-08
author:     Mr.Huang
header-img: img/2019.12.19.jpg
catalog: true
tags:
    - Python
---

# 前言

观看视频覃秉丰《Python入门》学习视频

## 学习内容


	模块
	
	证明该分类器在第二轮对抗攻击中是具有鲁棒性的
	
	证明所有防御方法有存在泛化限制，这是一个本质属性

### 模块

**模块是程序的集合体**

	import max 导入模块max
	from max import func_max #从max模块中仅导入func_max函数
	from max import *  #从max模块中导入所有函数
	import max as m #导入max，用as指定max的别名mm
	import os
	print(os.getcwd()) #获取当前文件所在路径

### 类基础

类是面向对象的基础，一系列相似属性的事物归为一类。  属性(基本特征)和方法(函数)

'''
class human: #类  包含初始化(本征属性)和方法    有什么？ 做什么？
    #初始化(在创建对象时会执行)
    def __init__(self,name='someone',age=10):
        self.name = name
        self.age = age
        print('human init')
    def my_name(self):
        print('my name is', self.name)
    def my_age(self):
        print('my age is:',self.age)
    def think(self,a,b):
        print(a+b)

class student(human):  #子类继承父类
    def __init__(self,grade=1,school='MIT'):
        # 继承父类的初始化
        super().__init__()  #父类的属性必须super才能使用，而方法自动继承, 添加子类自己的属性
        self.grade=grade
        self.school=school
        self.score=100
        print('student init')
    #自动继承父类的方法，添加子类自己的方法
    def learn(self):
        print('learning')
    def my_school(self):
        print('my schoool is',self.school)
    def think(self,a,b):    #子类可以重写父类的方法
        print(a*b)
stu1=student()
stu2=student(4)
print(stu1.grade)  #使用的是默认的1
print(stu2.grade)  #传入的参数是4，即更新了grad参数，由默认的1变为4
print(stu1.name)

#首先执行父类的初始化，然后执行子类的初始化，方法是自动继承的，子类可以重写父类的方法

stu3=student()
stu3.think(1,0)

'''

**类的继承要点：**

首先执行父类的初始化，然后执行子类的初始化，方法是自动继承的，子类可以重写父类的方法

###输入——Input

number = input('Please input a number:')  #输入的数字为 字符
if int(number) == 1:
    print("you have input number 1")
elif number == '2':
    print('you have input number 2')
else:
    print('bingo!')

**小知识**：注释一段代码可用以下两种方法，''' 代码''' 或 ctrl+？ 






### 对抗样本的防

+ 2016年Kurakin指出一些图像变换，如高斯噪声、高斯滤波器和JPEG压缩可以有效恢复80%以上的对抗样本
+ Papernot提出防御性网络蒸馏
+ Kurakin提出对抗训练

---

## 实验操作——二分器

1.利用模型f1训练干净样本，然后用模型f1通过攻击算法制作对抗样本

2.建立二分器模型f2进行有监督训练，（干净样本标记为0，对抗样本标记为1）

3.测试干净样本和对抗样本的识别准确率

4.利用模型f2构建第二轮对抗测试数据，测试f2的鲁棒性

本论文中的[二分器防御实验代码](https://github.com/gongzhitaao/adversarial-classifier)

同时，[对抗样本的生成]( https://github.com/gongzhitaao/tensorflow-adversarial)

打开adversarial-classifier项目，存在以下文件：

[![l3K0d1.md.jpg](https://s2.ax1x.com/2019/12/31/l3K0d1.md.jpg)](https://imgchr.com/i/l3K0d1)

我们需要在tensorflow-adversarial项目中导入攻击算法，将attacks文件夹拷贝到我们的项目中。

我们以src/table_1_mnist 为例，**我的环境配置：**Ubuntu 18.04+Python3.7+tensorflow 1.12+keras 2.3.0

由于笔者的环境和我的有些出入，故我将代码进行了以下更改

	keras  =>  tensorflow.keras
	from keras.utils import np_utils 删除该语句
	np_utils.to_categorical  =>  tf.keras.utils.to_categorical
	from attacks.fgsm import fgsm  => from attacks.fast_gradient import fgm

训练结果如下：

[![l31G79.md.png](https://s2.ax1x.com/2019/12/31/l31G79.md.png)](https://imgchr.com/i/l31G79)


**实验结果**

[![QLae4H.md.jpg](https://s2.ax1x.com/2019/12/19/QLae4H.md.jpg)](https://imgchr.com/i/QLae4H)

实验表明：

+ 对于测试的二分类方法，达到超过99%的准确率，同时对第二轮对抗攻击是具有鲁棒性的。

+ FGSM与JSMA生成的对抗样本是不兼容的，而FGSM与TGSM生成的对抗样本是兼容的，即分类器训练FGSM对抗样本集，也能在TGSM对抗样本的分类上表现不错。

**泛化限制**

> 利用FGSM/TGSM生成的对抗样本训练的二分类器对超参数敏感

> 对生成对抗样本的算法敏感

# 结语

 > 本文首次发布于 [Mr.Huang Blog](http://www.huangsz.xyz), 作者 [@(Mr.Huang)](http://github.com/EmotionalXX) ,转载请保留原文链接.
